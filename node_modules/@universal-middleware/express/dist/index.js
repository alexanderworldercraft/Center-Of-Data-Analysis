// src/common.ts
import { bindUniversal, getAdapterRuntime, universalSymbol } from "@universal-middleware/core";

// src/request.ts
var deno = typeof Deno !== "undefined";
var bun = typeof Bun !== "undefined";
function createRequestAdapter(options = {}) {
  const { origin = env.ORIGIN, trustProxy = env.TRUST_PROXY === "1" } = options;
  let { protocol: protocolOverride, host: hostOverride } = origin ? new URL(origin) : {};
  if (protocolOverride) {
    protocolOverride = protocolOverride.slice(0, -1);
  }
  let warned = false;
  return function requestAdapter(req) {
    if (req[requestSymbol]) {
      return req[requestSymbol];
    }
    function parseForwardedHeader(name) {
      return (headers[`x-forwarded-${name}`] || "").split(",", 1)[0].trim();
    }
    let headers = req.headers;
    if (headers[":method"]) {
      headers = Object.fromEntries(Object.entries(headers).filter(([key]) => !key.startsWith(":")));
    }
    const protocol = protocolOverride || req.protocol || trustProxy && parseForwardedHeader("proto") || req.socket?.encrypted && "https" || "http";
    let host = hostOverride || trustProxy && parseForwardedHeader("host") || headers.host;
    if (!host && !warned) {
      console.warn(
        "Could not automatically determine the origin host, using 'localhost'. Use the 'origin' option or the 'ORIGIN' environment variable to set the origin explicitly."
      );
      warned = true;
      host = "localhost";
    }
    const request = new Request(`${protocol}://${host}${req.originalUrl ?? req.url}`, {
      method: req.method,
      headers,
      body: convertBody(req),
      // @ts-ignore
      duplex: "half"
    });
    req[requestSymbol] = request;
    return request;
  };
}
function convertBody(req) {
  if (req.method === "GET" || req.method === "HEAD") {
    return;
  }
  if (req.rawBody !== void 0) {
    return req.rawBody;
  }
  if (!bun && !deno) {
    return req;
  }
  return new ReadableStream({
    start(controller) {
      req.on("data", (chunk) => controller.enqueue(chunk));
      req.on("end", () => controller.close());
      req.on("error", (err) => controller.error(err));
    }
  });
}

// src/response.ts
import { Readable } from "node:stream";
import { nodeHeadersToWeb } from "@universal-middleware/core";
var deno2 = typeof Deno !== "undefined";
async function sendResponse(fetchResponse, nodeResponse) {
  const fetchBody = fetchResponse.body;
  let body = null;
  if (!fetchBody) {
    body = null;
  } else if (typeof fetchBody.pipe === "function") {
    body = fetchBody;
  } else if (typeof fetchBody.pipeTo === "function") {
    if (!deno2 && Readable.fromWeb) {
      body = Readable.fromWeb(fetchBody);
    } else {
      const reader = fetchBody.getReader();
      body = new Readable({
        async read() {
          const { done, value } = await reader.read();
          this.push(done ? null : value);
        }
      });
    }
  } else if (fetchBody) {
    body = Readable.from(fetchBody);
  }
  setHeaders(fetchResponse, nodeResponse);
  if (body) {
    body.pipe(nodeResponse);
    await new Promise((resolve, reject) => {
      body.on("error", reject);
      nodeResponse.on("finish", resolve);
      nodeResponse.on("error", reject);
    });
  } else {
    nodeResponse.setHeader("content-length", "0");
    nodeResponse.end();
  }
}
function createTransformStream() {
  const textEncoder = new TextEncoder();
  return new TransformStream({
    transform(chunk, controller) {
      if (typeof chunk === "string") {
        controller.enqueue(textEncoder.encode(chunk));
      } else if (chunk instanceof Uint8Array) {
        controller.enqueue(chunk);
      } else {
        controller.enqueue(new Uint8Array(chunk));
      }
    }
  });
}
function override(nodeResponse, key, forwardTo) {
  const original = nodeResponse[key];
  nodeResponse[key] = (...args) => {
    if (!nodeResponse.headersSent) {
      nodeResponse.writeHead(nodeResponse.statusCode);
    }
    if (args[0] && args[0].length > 0) {
      forwardTo.write(args[0]).catch(console.error);
    }
    if (key === "end" && !forwardTo.closed) {
      forwardTo.close().catch(console.error);
    }
    return true;
  };
  return {
    original(...args) {
      original.apply(nodeResponse, args);
    },
    restore() {
      nodeResponse[key] = original;
    }
  };
}
function overrideWriteHead(nodeResponse, callback) {
  const original = nodeResponse.writeHead;
  nodeResponse.writeHead = (...args) => {
    const p = callback();
    nodeResponse[pendingWritesSymbol] ??= [];
    nodeResponse[pendingWritesSymbol].push(p);
    p.then(() => {
      if (nodeResponse.headersSent) {
        return nodeResponse;
      }
      original.apply(nodeResponse, args);
    });
    return nodeResponse;
  };
  return {
    original(...args) {
      original.apply(nodeResponse, args);
    },
    restore() {
      nodeResponse.writeHead = original;
    }
  };
}
function wrapResponse(nodeResponse) {
  if (nodeResponse[wrappedResponseSymbol]) return;
  nodeResponse[wrappedResponseSymbol] = true;
  const body = createTransformStream();
  const writer = body.writable.getWriter();
  const [reader1, reader2] = body.readable.tee();
  let readableToOriginal = reader2;
  const restore = [
    override(nodeResponse, "write", writer),
    override(nodeResponse, "end", writer),
    overrideWriteHead(nodeResponse, triggerPendingMiddlewares)
  ];
  let resolve;
  const pendingResponse = new Promise((r) => resolve = r);
  async function triggerPendingMiddlewares() {
    if (nodeResponse[pendingMiddlewaresSymbol]) {
      const middlewares = nodeResponse[pendingMiddlewaresSymbol];
      delete nodeResponse[pendingMiddlewaresSymbol];
      let response = await middlewares.reduce(
        async (prev, curr) => curr(await prev),
        Promise.resolve(
          new Response(reader1, {
            status: nodeResponse.statusCode,
            statusText: nodeResponse.statusMessage,
            headers: nodeHeadersToWeb(nodeResponse.getHeaders())
          })
        )
      );
      if (response.body && response.body !== reader1) {
        const [body1, body2] = response.body.tee();
        response = new Response(body1, response);
        readableToOriginal = body2;
      }
      setHeaders(response, nodeResponse, true);
      nodeResponse.flushHeaders();
      const wait = readableToOriginal.pipeTo(
        new WritableStream({
          write(chunk) {
            Promise.all(nodeResponse[pendingWritesSymbol] ?? []).then(() => {
              restore[0].original(chunk);
            });
          },
          close() {
            Promise.all(nodeResponse[pendingWritesSymbol] ?? []).then(() => {
              restore[1].original();
            });
          }
        })
      );
      await Promise.all([wait, writer.close()]);
      resolve();
      restore.forEach((r) => r.restore());
    } else {
      await pendingResponse;
    }
  }
}
function setHeaders(fetchResponse, nodeResponse, mirror = false) {
  nodeResponse.statusCode = fetchResponse.status;
  if (fetchResponse.statusText) {
    nodeResponse.statusMessage = fetchResponse.statusText;
  }
  const nodeResponseHeaders = new Set(Object.keys(nodeResponse.getHeaders()));
  const setCookie = fetchResponse.headers.getSetCookie();
  for (const cookie of setCookie) {
    nodeResponse.appendHeader("set-cookie", cookie);
  }
  fetchResponse.headers.forEach((value, key) => {
    nodeResponseHeaders.delete(key);
    if (key === "set-cookie") return;
    nodeResponse.setHeader(key, value);
  });
  if (mirror) {
    nodeResponseHeaders.forEach((key) => nodeResponse.removeHeader(key));
  }
}

// src/common.ts
var contextSymbol = Symbol.for("unContext");
var requestSymbol = Symbol.for("unRequest");
var pendingMiddlewaresSymbol = Symbol.for("unPendingMiddlewares");
var wrappedResponseSymbol = Symbol.for("unWrappedResponse");
var pendingWritesSymbol = Symbol.for("unPendingWrites");
var env = typeof globalThis.process?.env !== "undefined" ? globalThis.process.env : typeof import.meta?.env !== "undefined" ? import.meta.env : {};
function createHandler(handlerFactory, options = {}) {
  const requestAdapter = createRequestAdapter(options);
  return (...args) => {
    const handler = handlerFactory(...args);
    return bindUniversal(handler, async function universalHandlerExpress(req, res, next) {
      try {
        req[contextSymbol] ??= {};
        const request = requestAdapter(req);
        const response = await this[universalSymbol](request, req[contextSymbol], getRuntime(req, res));
        await sendResponse(response, res);
      } catch (error) {
        if (next) {
          next(error);
        } else {
          console.error(error);
          if (!res.headersSent) {
            res.statusCode = 500;
          }
          if (!res.writableEnded) {
            res.end();
          }
        }
      }
    });
  };
}
function createMiddleware(middlewareFactory, options = {}) {
  const requestAdapter = createRequestAdapter(options);
  return (...args) => {
    const middleware = middlewareFactory(...args);
    return bindUniversal(middleware, async function universalMiddlewareExpress(req, res, next) {
      try {
        req[contextSymbol] ??= {};
        const request = requestAdapter(req);
        const response = await this[universalSymbol](request, getContext(req), getRuntime(req, res));
        if (!response) {
          return next?.();
        }
        if (typeof response === "function") {
          if (res.headersSent) {
            throw new Error(
              "Universal Middleware called after headers have been sent. Please open an issue at https://github.com/magne4000/universal-middleware"
            );
          }
          wrapResponse(res);
          res[pendingMiddlewaresSymbol] ??= [];
          res[pendingMiddlewaresSymbol].push(response);
          return next?.();
        }
        if (response instanceof Response) {
          await sendResponse(response, res);
        } else {
          req[contextSymbol] = response;
          return next?.();
        }
      } catch (error) {
        if (next) {
          next(error);
        } else {
          console.error(error);
          if (!res.headersSent) {
            res.statusCode = 500;
          }
          if (!res.writableEnded) {
            res.end();
          }
        }
      }
    });
  };
}
function getContext(req) {
  return req[contextSymbol];
}
function getRuntime(request, response) {
  return getAdapterRuntime("express", {
    params: request.params,
    req: request,
    res: response,
    express: Object.freeze({
      req: request,
      res: response
    })
  });
}
export {
  createHandler,
  createMiddleware,
  createRequestAdapter,
  getContext,
  sendResponse
};
