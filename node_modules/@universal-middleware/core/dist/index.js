// src/runtime.ts
var knownUserAgents = {
  deno: "Deno",
  bun: "Bun",
  workerd: "Cloudflare-Workers",
  node: "Node.js"
};
var _getRuntimeKey = () => {
  const global = globalThis;
  const userAgentSupported = typeof navigator !== "undefined" && typeof navigator.userAgent === "string";
  if (userAgentSupported) {
    for (const [runtimeKey2, userAgent] of Object.entries(knownUserAgents)) {
      if (checkUserAgentEquals(userAgent)) {
        return runtimeKey2;
      }
    }
  }
  if (typeof global?.EdgeRuntime === "string") {
    return "edge-light";
  }
  if (global?.fastly !== void 0) {
    return "fastly";
  }
  if (global?.process?.release?.name === "node") {
    return "node";
  }
  return "other";
};
var runtimeKey = void 0;
var getRuntimeKey = () => {
  if (runtimeKey === void 0) {
    runtimeKey = _getRuntimeKey();
  }
  return runtimeKey;
};
var checkUserAgentEquals = (platform) => {
  const userAgent = navigator.userAgent;
  return userAgent.startsWith(platform);
};
function getRuntime(args) {
  const key = getRuntimeKey();
  return {
    runtime: key,
    ...args
  };
}

// src/adapter.ts
function getAdapter(key, args) {
  return {
    adapter: key,
    ...args
  };
}
function getAdapterRuntime(adapter, adapterArgs, runtimeArgs) {
  const a = getAdapter(adapter, adapterArgs);
  const r = getRuntime(runtimeArgs);
  return Object.freeze({ ...r, ...a });
}

// src/const.ts
var universalSymbol = Symbol.for("universal");
var unboundSymbol = Symbol.for("unbound");

// src/utils.ts
function isBodyInit(value) {
  return value === null || typeof value === "string" || value instanceof Blob || value instanceof ArrayBuffer || ArrayBuffer.isView(value) || value instanceof FormData || value instanceof URLSearchParams || value instanceof ReadableStream;
}
function mergeHeadersInto(first, ...sources) {
  for (const source of sources) {
    const headers = new Headers(source);
    for (const [key, value] of headers.entries()) {
      if (key === "set-cookie") {
        if (!first.getSetCookie().includes(value)) first.append(key, value);
      } else {
        if (first.get(key) !== value) first.set(key, value);
      }
    }
  }
  return first;
}
function nodeHeadersToWeb(nodeHeaders) {
  const headers = [];
  const keys = Object.keys(nodeHeaders);
  for (const key of keys) {
    headers.push([key, normalizeHttpHeader(nodeHeaders[key])]);
  }
  return new Headers(headers);
}
function normalizeHttpHeader(value) {
  if (Array.isArray(value)) {
    return value.join(", ");
  }
  return value || "";
}
function bindUniversal(universal, fn) {
  const unboundFn = unboundSymbol in fn ? fn[unboundSymbol] : fn;
  const self = { [universalSymbol]: universal, [unboundSymbol]: unboundFn };
  const boundFn = unboundFn.bind(self);
  Object.assign(boundFn, self);
  return boundFn;
}
function attachUniversal(universal, subject) {
  return Object.assign(subject, { [universalSymbol]: universal });
}

// src/pipe.ts
function pipe(...a) {
  const middlewares = a.map(
    (m) => universalSymbol in m ? m[universalSymbol] : m
  );
  const fn = async function pipeInternal(request, context, runtime) {
    const pending = [];
    let _response = void 0;
    for (const m of middlewares) {
      const response = await m(request, context ?? {}, runtime);
      if (typeof response === "function") {
        pending.push(response);
      } else if (response !== null && typeof response === "object") {
        if (response instanceof Response) {
          _response = response;
          break;
        }
        context = response;
      }
    }
    if (!_response) {
      throw new Error("No Response found");
    }
    for (const m of pending) {
      const r = await m(_response);
      if (r) {
        _response = r;
      }
    }
    return _response;
  };
  const lastMiddleware = a.at(-1);
  if (lastMiddleware && universalSymbol in lastMiddleware) {
    return bindUniversal(fn, lastMiddleware);
  }
  return fn;
}

// src/route.ts
import { parse } from "regexparam";
function exec(path, result) {
  const out = {};
  const matches = result.pattern.exec(path);
  if (!matches) return null;
  for (let i = 0; i < result.keys.length; i++) {
    if (matches[i + 1]) {
      out[result.keys[i]] = matches[i + 1];
    }
  }
  return out;
}
function paramsFromRequest(request, path) {
  const url = new URL(request.url);
  return exec(url.pathname, parse(path));
}
function params(request, runtime, path) {
  if (typeof path === "string") {
    return paramsFromRequest(request, path);
  }
  return runtime.params ?? null;
}

// src/env.ts
function env(runtime) {
  switch (runtime.runtime) {
    case "bun":
    case "node":
    case "edge-light":
      return globalThis?.process?.env;
    case "deno":
      return Deno.env.toObject();
    case "workerd":
      return runtime.env ?? {};
    default:
      return {};
  }
}
export {
  attachUniversal,
  bindUniversal,
  env,
  getAdapterRuntime,
  isBodyInit,
  mergeHeadersInto,
  nodeHeadersToWeb,
  params,
  pipe,
  universalSymbol
};
