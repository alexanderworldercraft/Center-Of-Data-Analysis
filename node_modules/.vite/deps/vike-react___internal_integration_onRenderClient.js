import {
  PageContextProvider
} from "./chunk-DMJCDK3N.js";
import {
  require_react_dom
} from "./chunk-TYILIMWK.js";
import {
  require_react
} from "./chunk-CANBAPAS.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports) {
    "use strict";
    var m = require_react_dom();
    if (false) {
      exports.createRoot = m.createRoot;
      exports.hydrateRoot = m.hydrateRoot;
    } else {
      i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      exports.createRoot = function(c, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.createRoot(c, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
      exports.hydrateRoot = function(c, h, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.hydrateRoot(c, h, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
    }
    var i;
  }
});

// node_modules/vike-react/dist/integration/onRenderClient.js
var import_client = __toESM(require_client());

// node_modules/vike-react/dist/utils/isCallable.js
function isCallable(thing) {
  return thing instanceof Function || typeof thing === "function";
}

// node_modules/vike-react/dist/hooks/useConfig/configsCumulative.js
var configsCumulative = ["Head", "bodyAttributes", "htmlAttributes"];

// node_modules/vike-react/dist/utils/includes.js
function includes(values, x) {
  return values.includes(x);
}

// node_modules/vike-react/dist/integration/getHeadSetting.js
function getHeadSetting(configName, pageContext) {
  var _a;
  const valFromUseConfig = (_a = pageContext._configFromHook) == null ? void 0 : _a[configName];
  const valFromConfig = pageContext.config[configName];
  const getCallable = (val) => isCallable(val) ? val(pageContext) : val;
  if (!includes(configsCumulative, configName)) {
    if (valFromUseConfig !== void 0)
      return valFromUseConfig;
    return getCallable(valFromConfig);
  } else {
    return [
      //
      ...(valFromConfig ?? []).map(getCallable),
      ...valFromUseConfig ?? []
    ];
  }
}

// node_modules/vike-react/dist/integration/getPageElement.js
var import_react = __toESM(require_react(), 1);
function getPageElement(pageContext) {
  const { Page, config: { Loading } } = pageContext;
  let page = Page ? import_react.default.createElement(Page, null) : null;
  const addSuspense = (el) => {
    if (!(Loading == null ? void 0 : Loading.layout))
      return el;
    return import_react.default.createElement(import_react.Suspense, { fallback: import_react.default.createElement(Loading.layout, null) }, page);
  };
  page = addSuspense(page);
  [
    // Inner wrapping
    ...pageContext.config.Layout || [],
    // Outer wrapping
    ...pageContext.config.Wrapper || []
  ].forEach((Wrap) => {
    page = import_react.default.createElement(Wrap, null, page);
    page = addSuspense(page);
  });
  page = import_react.default.createElement(PageContextProvider, { pageContext }, page);
  let renderPromiseResolve;
  let renderPromise = new Promise((r) => renderPromiseResolve = r);
  page = import_react.default.createElement(RenderPromiseProvider, { renderPromiseResolve }, page);
  if (pageContext.config.reactStrictMode !== false) {
    page = import_react.default.createElement(import_react.default.StrictMode, null, page);
  }
  return { page, renderPromise };
}
function RenderPromiseProvider({ children, renderPromiseResolve }) {
  (0, import_react.useEffect)(renderPromiseResolve);
  return children;
}

// node_modules/vike-react/dist/integration/onRenderClient.js
import "/home/alexander/Documents/Professionnel/React/Center-Of-Data-Analysis/node_modules/vike-react/dist/integration/styles.css";

// node_modules/vike-react/dist/utils/callCumulativeHooks.js
import { providePageContext } from "vike/getPageContext";
async function callCumulativeHooks(values, pageContext) {
  if (!values)
    return [];
  const valuesPromises = values.map((val) => {
    if (typeof val === "function") {
      providePageContext(pageContext);
      return val(pageContext);
    } else {
      return val;
    }
  });
  const valuesResolved = await Promise.all(valuesPromises);
  return valuesResolved;
}

// node_modules/vike-react/dist/integration/applyHeadSettings.js
function applyHeadSettings(title, lang) {
  if (title !== void 0)
    document.title = title || "";
  if (lang !== void 0)
    document.documentElement.lang = lang || "en";
}

// node_modules/vike-react/dist/integration/onRenderClient.js
var root;
var onRenderClient = async (pageContext) => {
  pageContext._headAlreadySet = pageContext.isHydration;
  await callCumulativeHooks(pageContext.config.onBeforeRenderClient, pageContext);
  const { page, renderPromise } = getPageElement(pageContext);
  pageContext.page = page;
  const onUncaughtError = (_error, _errorInfo) => {
  };
  const container = document.getElementById("root");
  if (pageContext.isHydration && // Whether the page was [Server-Side Rendered](https://vike.dev/ssr).
  container.innerHTML !== "") {
    root = import_client.default.hydrateRoot(container, page, {
      // @ts-expect-error
      onUncaughtError
    });
  } else {
    if (!root) {
      root = import_client.default.createRoot(container, {
        // @ts-expect-error
        onUncaughtError
      });
    }
    root.render(page);
  }
  pageContext.root = root;
  await renderPromise;
  if (!pageContext.isHydration) {
    pageContext._headAlreadySet = true;
    applyHead(pageContext);
  }
  await callCumulativeHooks(pageContext.config.onAfterRenderClient, pageContext);
};
function applyHead(pageContext) {
  const title = getHeadSetting("title", pageContext);
  const lang = getHeadSetting("lang", pageContext);
  applyHeadSettings(title, lang);
}
export {
  onRenderClient
};
//# sourceMappingURL=vike-react___internal_integration_onRenderClient.js.map
