{
  "version": 3,
  "sources": ["../../telefunc/dist/esm/client/clientConfig.js", "../../telefunc/dist/esm/client/remoteTelefunctionCall/onAbort.js", "../../@brillout/json-serializer/dist/esm/types.js", "../../@brillout/json-serializer/dist/esm/parse.js", "../../telefunc/dist/esm/client/remoteTelefunctionCall/makeHttpRequest.js", "../../@brillout/json-serializer/dist/esm/utils/isReactElement.js", "../../@brillout/json-serializer/dist/esm/utils/isCallable.js", "../../@brillout/json-serializer/dist/esm/utils/isObject.js", "../../@brillout/json-serializer/dist/esm/utils/replacerWithPath.js", "../../@brillout/json-serializer/dist/esm/stringify.js", "../../telefunc/dist/esm/client/remoteTelefunctionCall/serializeTelefunctionArguments.js", "../../telefunc/dist/esm/client/remoteTelefunctionCall.js"],
  "sourcesContent": ["export { configUser as config };\nexport { resolveClientConfig };\nimport { assertUsage } from './utils';\nconst configUser = new Proxy({}, { set: validateUserConfig });\nfunction resolveClientConfig() {\n    var _a;\n    return {\n        httpHeaders: (_a = configUser.httpHeaders) !== null && _a !== void 0 ? _a : null,\n        telefuncUrl: configUser.telefuncUrl || '/_telefunc',\n    };\n}\nfunction validateUserConfig(configUserUnwrapped, prop, val) {\n    if (prop === 'telefuncUrl') {\n        assertUsage(typeof val === 'string', 'config.telefuncUrl should be a string');\n        const isIpAddress = (value) => /^\\d/.test(value);\n        assertUsage(val.startsWith('/') || val.startsWith('http') || isIpAddress(val), `config.telefuncUrl (client-side) is '${val}' but it should be one of the following: a URL pathname (such as '/_telefunc'), a URL with origin (such as 'https://example.org/_telefunc'), or an IP address (such as '192.158.1.38') â€” see https://telefunc.com/telefuncUrl`);\n        configUserUnwrapped[prop] = val;\n    }\n    else if (prop === 'httpHeaders') {\n        assertUsage(typeof val === 'object' && val !== null && Object.values(val).every((v) => typeof v === 'string'), '`config.httpHeaders` should be an object of strings');\n        configUserUnwrapped[prop] = val;\n    }\n    else {\n        assertUsage(false, `Unknown config.${prop}`);\n    }\n    return true;\n}\n", "export { onAbort };\nexport { callOnAbortListeners };\nexport { onTelefunctionRemoteCallError };\nimport { assertWarning } from '../utils';\n/** Outdated: use onAbort() instead */\nfunction onTelefunctionRemoteCallError(listener) {\n    assertWarning(false, 'onTelefunctionRemoteCallError() deprecated in favor of onAbort()', {\n        onlyOnce: true,\n        showStackTrace: true,\n    });\n    onAbort(listener);\n}\nfunction onAbort(listener) {\n    window.__telefunc_errorListeners = window.__telefunc_errorListeners || [];\n    window.__telefunc_errorListeners.push(listener);\n}\nfunction callOnAbortListeners(err) {\n    ;\n    (window.__telefunc_errorListeners || []).forEach((listener) => {\n        listener(err);\n    });\n}\n", "export { types };\nconst types = [\n    ts({\n        is: (val) => val === undefined,\n        match: (str) => str === '!undefined',\n        serialize: () => '!undefined',\n        deserialize: () => undefined,\n    }),\n    ts({\n        is: (val) => val === Infinity,\n        match: (str) => str === '!Infinity',\n        serialize: () => '!Infinity',\n        deserialize: () => Infinity,\n    }),\n    ts({\n        is: (val) => val === -Infinity,\n        match: (str) => str === '!-Infinity',\n        serialize: () => '!-Infinity',\n        deserialize: () => -Infinity,\n    }),\n    ts({\n        is: (val) => typeof val === 'number' && isNaN(val),\n        match: (str) => str === '!NaN',\n        serialize: () => '!NaN',\n        deserialize: () => NaN,\n    }),\n    ts({\n        is: (val) => val instanceof Date,\n        match: (str) => str.startsWith('!Date:'),\n        serialize: (val) => '!Date:' + val.toISOString(),\n        deserialize: (str) => new Date(str.slice('!Date:'.length)),\n    }),\n    ts({\n        is: (val) => typeof val === 'bigint',\n        match: (str) => str.startsWith('!BigInt:'),\n        serialize: (val) => '!BigInt:' + val.toString(),\n        deserialize: (str) => {\n            if (typeof BigInt === 'undefined') {\n                throw new Error('Your JavaScript environement does not support BigInt. Consider adding a polyfill.');\n            }\n            return BigInt(str.slice('!BigInt:'.length));\n        },\n    }),\n    ts({\n        is: (val) => val instanceof RegExp,\n        match: (str) => str.startsWith('!RegExp:'),\n        serialize: (val) => '!RegExp:' + val.toString(),\n        deserialize: (str) => {\n            str = str.slice('!RegExp:'.length);\n            // const args: string[] = str.match(/\\/(.*?)\\/([gimy])?$/)!\n            const args = str.match(/\\/(.*)\\/(.*)?/);\n            const pattern = args[1];\n            const flags = args[2];\n            return new RegExp(pattern, flags);\n        },\n    }),\n    ts({\n        is: (val) => val instanceof Map,\n        match: (str) => str.startsWith('!Map:'),\n        serialize: (val, serializer) => '!Map:' + serializer(Array.from(val.entries())),\n        deserialize: (str, deserializer) => new Map(deserializer(str.slice('!Map:'.length))),\n    }),\n    ts({\n        is: (val) => val instanceof Set,\n        match: (str) => str.startsWith('!Set:'),\n        serialize: (val, serializer) => '!Set:' + serializer(Array.from(val.values())),\n        deserialize: (str, deserializer) => new Set(deserializer(str.slice('!Set:'.length))),\n    }),\n    // Avoid collisions with the special strings defined above\n    ts({\n        is: (val) => typeof val === 'string' && val.startsWith('!'),\n        match: (str) => str.startsWith('!'),\n        serialize: (val) => '!' + val,\n        deserialize: (str) => str.slice(1),\n    }),\n];\n// Type check\nfunction ts(t) {\n    return t;\n}\n", "export { parse };\n// Used by Vike: https://github.com/vikejs/vike/blob/b4ba6b70e6bdc2e1f460c0d2e4c3faae5d0a733c/vike/shared/page-configs/serialize/parseConfigValuesSerialized.ts#L13\nexport { parseTransform };\nimport { types } from './types';\nfunction parse(str) {\n    // We don't use the reviver option in `JSON.parse(str, reviver)` because it doesn't support `undefined` values\n    const value = JSON.parse(str);\n    return parseTransform(value);\n}\nfunction parseTransform(value) {\n    if (typeof value === 'string') {\n        return reviver(value);\n    }\n    if (\n    // Also matches arrays\n    typeof value === 'object' &&\n        value !== null) {\n        Object.entries(value).forEach(([key, val]) => {\n            ;\n            value[key] = parseTransform(val);\n        });\n    }\n    return value;\n}\nfunction reviver(value) {\n    for (const { match, deserialize } of types) {\n        if (match(value)) {\n            return deserialize(value, parse);\n        }\n    }\n    return value;\n}\n", "export { makeHttpRequest };\nimport { parse } from '@brillout/json-serializer/parse';\nimport { assert, assertUsage, isObject, objectAssign } from '../utils';\nimport { callOnAbortListeners } from './onAbort';\nconst method = 'POST';\nconst STATUS_CODE_SUCCESS = 200;\nconst STATUS_CODE_ABORT = 403;\nconst STATUS_CODE_BUG = 500;\nconst STATUS_CODE_INVALID = 400;\nasync function makeHttpRequest(callContext) {\n    let response;\n    try {\n        response = await fetch(callContext.telefuncUrl, {\n            method,\n            body: callContext.httpRequestBody,\n            credentials: 'same-origin',\n            headers: {\n                ...callContext.httpHeaders,\n                'Content-Type': 'text/plain',\n            },\n        });\n    }\n    catch (_) {\n        const telefunctionCallError = new Error('No Server Connection');\n        objectAssign(telefunctionCallError, { isConnectionError: true });\n        throw telefunctionCallError;\n    }\n    const statusCode = response.status;\n    if (statusCode === STATUS_CODE_SUCCESS) {\n        const { ret } = await parseResponseBody(response, callContext);\n        const telefunctionReturn = ret;\n        return { telefunctionReturn };\n    }\n    else if (statusCode === STATUS_CODE_ABORT) {\n        const { ret } = await parseResponseBody(response, callContext);\n        const abortValue = ret;\n        const telefunctionCallError = new Error(`Aborted telefunction call ${callContext.telefunctionName}() (${callContext.telefuncFilePath}).`);\n        objectAssign(telefunctionCallError, { isAbort: true, abortValue });\n        callOnAbortListeners(telefunctionCallError);\n        throw telefunctionCallError;\n    }\n    else if (statusCode === STATUS_CODE_BUG) {\n        const responseBody = await response.text();\n        const errMsg = 'Internal Server Error';\n        assertUsage(responseBody === errMsg, installErr({\n            reason: 'an HTTP response body that Telefunc never generates',\n            method,\n            callContext,\n        }));\n        throw new Error(errMsg);\n    }\n    else if (statusCode === STATUS_CODE_INVALID) {\n        const responseBody = await response.text();\n        assertUsage(responseBody === 'Invalid Telefunc Request', installErr({\n            reason: 'an HTTP response body that Telefunc never generates',\n            method,\n            callContext,\n        }));\n        /* With Next.js 12: when renaming a `.telefunc.js` file the client makes a request with the new `.telefunc.js` name while the server is still serving the old `.telefunc.js` name. Seems like a race condition: trying again seems to fix the error.\n        // This should never happen as the Telefunc Client shouldn't make invalid requests\n        assert(false)\n        */\n        assertUsage(false, 'Try again. You may need to reload the page. (The client and server are/was out-of-sync.)');\n    }\n    else {\n        assertUsage(statusCode !== 404, installErr({\n            reason: 'a 404 HTTP response',\n            method,\n            isNotInstalled: true,\n            callContext,\n        }));\n        assertUsage(false, installErr({\n            reason: `a status code \\`${statusCode}\\` which Telefunc never uses`,\n            method,\n            callContext,\n        }));\n    }\n}\nasync function parseResponseBody(response, callContext) {\n    const responseBody = await response.text();\n    const responseBodyParsed = parse(responseBody);\n    assertUsage(isObject(responseBodyParsed) && 'ret' in responseBodyParsed, installErr({\n        reason: 'an HTTP response body that Telefunc never generates',\n        method,\n        callContext,\n    }));\n    assert(response.status !== STATUS_CODE_ABORT || 'abort' in responseBodyParsed);\n    const { ret } = responseBodyParsed;\n    return { ret };\n}\nfunction installErr({ reason, callContext, method, isNotInstalled, }) {\n    let msg = [`Telefunc doesn't seem to be `];\n    if (!isNotInstalled) {\n        msg.push('(properly) ');\n    }\n    msg.push('installed on your server');\n    if (reason) {\n        msg.push(...[`: the HTTP ${method} \\`${callContext.telefuncUrl}\\` request returned `, reason]);\n    }\n    msg.push(`, see https://telefunc.com/install`);\n    return msg.join('');\n}\n", "export function isReactElement(value) {\n    return (typeof value === 'object' &&\n        value !== null &&\n        String(value['$$typeof']) === 'Symbol(react.element)');\n}\n", "export function isCallable(thing) {\n    return thing instanceof Function || typeof thing === 'function';\n}\n", "export { isObject };\nfunction isObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    if (Array.isArray(value)) {\n        return false;\n    }\n    return true;\n}\n", "export { replacerWithPath };\nfunction replacerWithPath(replacer) {\n    const pathMap = new WeakMap();\n    return function (key, value) {\n        const pathPrevious = pathMap.get(this) ?? [];\n        const path = [...pathPrevious];\n        if (key !== '') {\n            const pathEntry = !Array.isArray(this) ? key : parseInt(key, 10);\n            path.push(pathEntry);\n        }\n        if (isIterable(value))\n            pathMap.set(value, path);\n        return replacer.call(this, key, value, path);\n    };\n}\nfunction isIterable(value) {\n    return value === Object(value);\n}\n", "export { stringify };\nexport { isJsonSerializerError };\nimport { types } from './types';\nimport { isReactElement } from './utils/isReactElement';\nimport { isCallable } from './utils/isCallable';\nimport { isObject } from './utils/isObject';\nimport { replacerWithPath } from './utils/replacerWithPath';\nfunction stringify(value, { forbidReactElements, space, valueName, sortObjectKeys, \n// Used by Vike: https://github.com/vikejs/vike/blob/b4ba6b70e6bdc2e1f460c0d2e4c3faae5d0a733c/vike/node/plugin/plugins/importUserCode/v1-design/getConfigValuesSerialized.ts#L78\nreplacer: replacerUserProvided, } = {}) {\n    // The only error `JSON.stringify()` can throw is `TypeError \"cyclic object value\"`.\n    // - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#exceptions\n    // - This means we have total of 3 possible errors while serializing:\n    //    - Cyclic references\n    //    - Functions\n    //    - React elements\n    const serializer = (val) => JSON.stringify(val, replacerWithPath(replacer), space);\n    return serializer(value);\n    function replacer(key, value, path) {\n        {\n            const ret = replacerUserProvided?.call(this, key, value);\n            if (ret)\n                return ret.replacement;\n        }\n        if (forbidReactElements && isReactElement(value)) {\n            throw genErr({\n                value,\n                valueType: 'React element',\n                path,\n                rootValueName: valueName,\n            });\n        }\n        if (isCallable(value)) {\n            const functionName = value.name;\n            throw genErr({\n                value,\n                valueType: 'function',\n                path,\n                rootValueName: valueName,\n                problematicValueName: path.length === 0 ? functionName : undefined,\n            });\n        }\n        const valueOriginal = this[key];\n        for (const { is, serialize } of types.slice().reverse()) {\n            if (is(valueOriginal)) {\n                //@ts-ignore\n                return serialize(valueOriginal, serializer);\n            }\n        }\n        if (sortObjectKeys && isObject(value)) {\n            const copy = {};\n            Object.keys(value)\n                .sort()\n                .forEach((key) => {\n                copy[key] = value[key];\n            });\n            value = copy;\n        }\n        return value;\n    }\n}\nfunction genErr({ value, valueType, path, rootValueName, problematicValueName, }) {\n    const subjectName = getSubjectName({ path, rootValueName, problematicValueName });\n    const messageCore = `cannot serialize ${subjectName} because it's a ${valueType}`;\n    const err = new Error(`[@brillout/json-serializer](https://github.com/brillout/json-serializer) ${messageCore}.`);\n    const pathString = getPathString(path, true);\n    const errAddendum = {\n        [stamp]: true,\n        messageCore,\n        value,\n        path,\n        pathString,\n        subjectName,\n    };\n    Object.assign(err, errAddendum);\n    return err;\n}\nconst stamp = '_isJsonSerializerError';\nfunction isJsonSerializerError(thing) {\n    return isObject(thing) && thing[stamp] === true;\n}\nfunction getSubjectName({ path, rootValueName, problematicValueName, }) {\n    const pathString = getPathString(path, !rootValueName);\n    let subjectName;\n    if (!pathString) {\n        subjectName = rootValueName || problematicValueName || 'value';\n    }\n    else {\n        if (problematicValueName) {\n            subjectName = problematicValueName + ' at ';\n        }\n        else {\n            subjectName = '';\n        }\n        subjectName = subjectName + (rootValueName || '') + pathString;\n    }\n    return subjectName;\n}\nfunction getPathString(path, canBeFirstKey) {\n    const pathString = path\n        .map((key, i) => {\n        if (typeof key === 'number') {\n            return `[${key}]`;\n        }\n        if (i === 0 && canBeFirstKey && isKeyDotNotationCompatible(key)) {\n            return key;\n        }\n        return getPropAccessNotation(key);\n    })\n        .join('');\n    return pathString;\n}\nfunction getPropAccessNotation(key) {\n    return typeof key === 'string' && isKeyDotNotationCompatible(key) ? `.${key}` : `[${JSON.stringify(key)}]`;\n}\nfunction isKeyDotNotationCompatible(key) {\n    return /^[a-z0-9\\$_]+$/i.test(key);\n}\n", "export { serializeTelefunctionArguments };\nimport { stringify } from '@brillout/json-serializer/stringify';\nimport { assert, assertUsage, lowercaseFirstLetter, hasProp } from '../utils';\nfunction serializeTelefunctionArguments(callContext) {\n    const bodyParsed = {\n        file: callContext.telefuncFilePath,\n        name: callContext.telefunctionName,\n        args: callContext.telefunctionArgs,\n    };\n    assert(typeof callContext.telefuncFilePath === 'string');\n    assert(typeof callContext.telefunctionName === 'string');\n    assert(Array.isArray(callContext.telefunctionArgs));\n    let httpRequestBody;\n    try {\n        httpRequestBody = stringify(bodyParsed, { forbidReactElements: true });\n    }\n    catch (err) {\n        assert(hasProp(err, 'message', 'string'));\n        assertUsage(false, [\n            `Cannot serialize arguments for telefunction ${callContext.telefunctionName}() (${callContext.telefuncFilePath}).`,\n            'Make sure that the arguments pass to telefunction calls are always serializable.',\n            `Serialization error: ${lowercaseFirstLetter(err.message)}`,\n        ].join(' '));\n    }\n    assert(httpRequestBody);\n    return httpRequestBody;\n}\n", "export { remoteTelefunctionCall };\nimport { makeHttpRequest } from './remoteTelefunctionCall/makeHttpRequest';\nimport { serializeTelefunctionArguments } from './remoteTelefunctionCall/serializeTelefunctionArguments';\nimport { resolveClientConfig } from './clientConfig';\nimport { objectAssign, assertUsage, isBrowser } from './utils';\nasync function remoteTelefunctionCall(telefuncFilePath, telefunctionName, telefunctionArgs) {\n    assertUsage(isBrowser(), 'The Telefunc Client is meant to be run only in the browser.');\n    const callContext = {};\n    {\n        objectAssign(callContext, {\n            telefuncFilePath,\n            telefunctionName,\n            telefunctionArgs,\n        });\n    }\n    objectAssign(callContext, resolveClientConfig());\n    {\n        const httpRequestBody = serializeTelefunctionArguments(callContext);\n        objectAssign(callContext, { httpRequestBody });\n    }\n    const { telefunctionReturn } = await makeHttpRequest(callContext);\n    return telefunctionReturn;\n}\n"],
  "mappings": "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",
  "names": ["method", "isObject", "value", "isObject", "key"]
}
