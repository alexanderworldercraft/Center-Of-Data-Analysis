// node_modules/telefunc/dist/esm/utils/createErrorWithCleanStackTrace.js
function createErrorWithCleanStackTrace(errorMessage, numberOfStackTraceLinesToRemove2) {
  const err = new Error(errorMessage);
  err.stack = clean(err.stack, numberOfStackTraceLinesToRemove2);
  return err;
}
function clean(errStack, numberOfStackTraceLinesToRemove2) {
  if (!errStack) {
    return errStack;
  }
  const stackLines = splitByLine(errStack);
  let linesRemoved = 0;
  const stackLine__cleaned = stackLines.filter((line) => {
    if (line.includes(" (internal/") || line.includes(" (node:internal")) {
      return false;
    }
    if (linesRemoved < numberOfStackTraceLinesToRemove2 && isStackTraceLine(line)) {
      linesRemoved++;
      return false;
    }
    return true;
  }).join("\n");
  return stackLine__cleaned;
}
function isStackTraceLine(line) {
  return line.startsWith("    at ");
}
function splitByLine(str) {
  return str.split(/\r?\n/);
}

// node_modules/telefunc/dist/esm/utils/getGlobalObject.js
function getGlobalObject(key, defaultValue) {
  const globalObjectsAll = globalThis[projectKey] = globalThis[projectKey] || {};
  const globalObject2 = globalObjectsAll[key] = globalObjectsAll[key] || defaultValue;
  return globalObject2;
}
var projectKey = "_telefunc";

// node_modules/telefunc/dist/esm/utils/PROJECT_VERSION.js
var PROJECT_VERSION = "0.1.82";

// node_modules/telefunc/dist/esm/utils/projectInfo.js
var projectInfo = {
  projectName: "Telefunc",
  projectVersion: PROJECT_VERSION
};

// node_modules/telefunc/dist/esm/utils/assert.js
var errorPrefix = `[telefunc@${projectInfo.projectVersion}]`;
var internalErrorPrefix = `${errorPrefix}[Bug]`;
var usageErrorPrefix = `${errorPrefix}[Wrong Usage]`;
var warningPrefix = `${errorPrefix}[Warning]`;
var infoPrefix = `${errorPrefix}[Info]`;
var numberOfStackTraceLinesToRemove = 2;
function assert(condition, debugInfo) {
  if (condition) {
    return;
  }
  const debugStr = (() => {
    if (!debugInfo) {
      return "";
    }
    const debugInfoSerialized = typeof debugInfo === "string" ? debugInfo : "`" + JSON.stringify(debugInfo) + "`";
    return `Debug info (this is for the ${projectInfo.projectName} maintainers; you can ignore this): ${debugInfoSerialized}.`;
  })();
  const link = "https://github.com/brillout/telefunc/issues/new";
  const internalError = createErrorWithCleanStackTrace([
    internalErrorPrefix,
    `You stumbled upon a Telefunc bug. Go to ${link} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,
    debugStr
  ].join(" "), numberOfStackTraceLinesToRemove);
  throw internalError;
}
function assertUsage(condition, errorMessage) {
  if (condition) {
    return;
  }
  const whiteSpace = errorMessage.startsWith("[") ? "" : " ";
  const usageError = createErrorWithCleanStackTrace(`${usageErrorPrefix}${whiteSpace}${errorMessage}`, numberOfStackTraceLinesToRemove);
  throw usageError;
}
var globalObject = getGlobalObject("assert.ts", { alreadyLogged: /* @__PURE__ */ new Set() });
function assertWarning(condition, errorMessage, { onlyOnce, showStackTrace }) {
  if (condition) {
    return;
  }
  const msg = `${warningPrefix} ${errorMessage}`;
  if (onlyOnce) {
    const { alreadyLogged } = globalObject;
    const key = onlyOnce === true ? msg : onlyOnce;
    if (alreadyLogged.has(key)) {
      return;
    } else {
      alreadyLogged.add(key);
    }
  }
  if (showStackTrace) {
    console.warn(new Error(msg));
  } else {
    console.warn(msg);
  }
}

// node_modules/telefunc/dist/esm/utils/isBrowser.js
function isBrowser() {
  const itIs = __browserTest();
  assert(itIs === !__nodeTest());
  return itIs;
}
function __nodeTest() {
  const nodeVersion = typeof process !== "undefined" && process && process.versions && process.versions.node;
  return !!nodeVersion;
}
function __browserTest() {
  return typeof window !== "undefined";
}

// node_modules/telefunc/dist/esm/utils/isObject.js
function isObject(value) {
  return typeof value === "object" && value !== null;
}

// node_modules/telefunc/dist/esm/utils/objectAssign.js
function objectAssign(obj, objAddendum) {
  Object.assign(obj, objAddendum);
}

// node_modules/telefunc/dist/esm/utils/lowercaseFirstLetter.js
function lowercaseFirstLetter(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

// node_modules/telefunc/dist/esm/utils/isCallable.js
function isCallable(thing) {
  return thing instanceof Function || typeof thing === "function";
}

// node_modules/telefunc/dist/esm/utils/hasProp.js
function hasProp(obj, prop, type = "unknown") {
  const propExists = typeof obj === "object" && obj !== null && prop in obj;
  if (!propExists) {
    return false;
  }
  if (type === "unknown") {
    return true;
  }
  const propValue = obj[prop];
  if (type === "array") {
    return Array.isArray(propValue);
  }
  if (type === "string[]") {
    return Array.isArray(propValue) && propValue.every((el) => typeof el === "string");
  }
  if (type === "function") {
    return isCallable(propValue);
  }
  if (Array.isArray(type)) {
    return typeof propValue === "string" && type.includes(propValue);
  }
  if (type === "null") {
    return propValue === null;
  }
  if (type === "true") {
    return propValue === true;
  }
  return typeof propValue === type;
}

export {
  assert,
  assertUsage,
  assertWarning,
  isBrowser,
  isObject,
  objectAssign,
  lowercaseFirstLetter,
  hasProp
};
//# sourceMappingURL=chunk-JB5ND3YJ.js.map
