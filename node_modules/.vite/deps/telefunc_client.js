import {
  assert,
  assertUsage,
  assertWarning,
  hasProp,
  isBrowser,
  isObject,
  lowercaseFirstLetter,
  objectAssign
} from "./chunk-JB5ND3YJ.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/telefunc/dist/esm/client/clientConfig.js
var configUser = new Proxy({}, { set: validateUserConfig });
function resolveClientConfig() {
  var _a;
  return {
    httpHeaders: (_a = configUser.httpHeaders) !== null && _a !== void 0 ? _a : null,
    telefuncUrl: configUser.telefuncUrl || "/_telefunc"
  };
}
function validateUserConfig(configUserUnwrapped, prop, val) {
  if (prop === "telefuncUrl") {
    assertUsage(typeof val === "string", "config.telefuncUrl should be a string");
    const isIpAddress = (value) => /^\d/.test(value);
    assertUsage(val.startsWith("/") || val.startsWith("http") || isIpAddress(val), `config.telefuncUrl (client-side) is '${val}' but it should be one of the following: a URL pathname (such as '/_telefunc'), a URL with origin (such as 'https://example.org/_telefunc'), or an IP address (such as '192.158.1.38') â€” see https://telefunc.com/telefuncUrl`);
    configUserUnwrapped[prop] = val;
  } else if (prop === "httpHeaders") {
    assertUsage(typeof val === "object" && val !== null && Object.values(val).every((v) => typeof v === "string"), "`config.httpHeaders` should be an object of strings");
    configUserUnwrapped[prop] = val;
  } else {
    assertUsage(false, `Unknown config.${prop}`);
  }
  return true;
}

// node_modules/telefunc/dist/esm/client/remoteTelefunctionCall/onAbort.js
function onTelefunctionRemoteCallError(listener) {
  assertWarning(false, "onTelefunctionRemoteCallError() deprecated in favor of onAbort()", {
    onlyOnce: true,
    showStackTrace: true
  });
  onAbort(listener);
}
function onAbort(listener) {
  window.__telefunc_errorListeners = window.__telefunc_errorListeners || [];
  window.__telefunc_errorListeners.push(listener);
}
function callOnAbortListeners(err) {
  ;
  (window.__telefunc_errorListeners || []).forEach((listener) => {
    listener(err);
  });
}

// node_modules/@brillout/json-serializer/dist/esm/types.js
var types = [
  ts({
    is: (val) => val === void 0,
    match: (str) => str === "!undefined",
    serialize: () => "!undefined",
    deserialize: () => void 0
  }),
  ts({
    is: (val) => val === Infinity,
    match: (str) => str === "!Infinity",
    serialize: () => "!Infinity",
    deserialize: () => Infinity
  }),
  ts({
    is: (val) => val === -Infinity,
    match: (str) => str === "!-Infinity",
    serialize: () => "!-Infinity",
    deserialize: () => -Infinity
  }),
  ts({
    is: (val) => typeof val === "number" && isNaN(val),
    match: (str) => str === "!NaN",
    serialize: () => "!NaN",
    deserialize: () => NaN
  }),
  ts({
    is: (val) => val instanceof Date,
    match: (str) => str.startsWith("!Date:"),
    serialize: (val) => "!Date:" + val.toISOString(),
    deserialize: (str) => new Date(str.slice("!Date:".length))
  }),
  ts({
    is: (val) => typeof val === "bigint",
    match: (str) => str.startsWith("!BigInt:"),
    serialize: (val) => "!BigInt:" + val.toString(),
    deserialize: (str) => {
      if (typeof BigInt === "undefined") {
        throw new Error("Your JavaScript environement does not support BigInt. Consider adding a polyfill.");
      }
      return BigInt(str.slice("!BigInt:".length));
    }
  }),
  ts({
    is: (val) => val instanceof RegExp,
    match: (str) => str.startsWith("!RegExp:"),
    serialize: (val) => "!RegExp:" + val.toString(),
    deserialize: (str) => {
      str = str.slice("!RegExp:".length);
      const args = str.match(/\/(.*)\/(.*)?/);
      const pattern = args[1];
      const flags = args[2];
      return new RegExp(pattern, flags);
    }
  }),
  ts({
    is: (val) => val instanceof Map,
    match: (str) => str.startsWith("!Map:"),
    serialize: (val, serializer) => "!Map:" + serializer(Array.from(val.entries())),
    deserialize: (str, deserializer) => new Map(deserializer(str.slice("!Map:".length)))
  }),
  ts({
    is: (val) => val instanceof Set,
    match: (str) => str.startsWith("!Set:"),
    serialize: (val, serializer) => "!Set:" + serializer(Array.from(val.values())),
    deserialize: (str, deserializer) => new Set(deserializer(str.slice("!Set:".length)))
  }),
  // Avoid collisions with the special strings defined above
  ts({
    is: (val) => typeof val === "string" && val.startsWith("!"),
    match: (str) => str.startsWith("!"),
    serialize: (val) => "!" + val,
    deserialize: (str) => str.slice(1)
  })
];
function ts(t) {
  return t;
}

// node_modules/@brillout/json-serializer/dist/esm/parse.js
function parse(str) {
  const value = JSON.parse(str);
  return parseTransform(value);
}
function parseTransform(value) {
  if (typeof value === "string") {
    return reviver(value);
  }
  if (
    // Also matches arrays
    typeof value === "object" && value !== null
  ) {
    Object.entries(value).forEach(([key, val]) => {
      ;
      value[key] = parseTransform(val);
    });
  }
  return value;
}
function reviver(value) {
  for (const { match, deserialize } of types) {
    if (match(value)) {
      return deserialize(value, parse);
    }
  }
  return value;
}

// node_modules/telefunc/dist/esm/client/remoteTelefunctionCall/makeHttpRequest.js
var method = "POST";
var STATUS_CODE_SUCCESS = 200;
var STATUS_CODE_ABORT = 403;
var STATUS_CODE_BUG = 500;
var STATUS_CODE_INVALID = 400;
async function makeHttpRequest(callContext) {
  let response;
  try {
    response = await fetch(callContext.telefuncUrl, {
      method,
      body: callContext.httpRequestBody,
      credentials: "same-origin",
      headers: {
        ...callContext.httpHeaders,
        "Content-Type": "text/plain"
      }
    });
  } catch (_) {
    const telefunctionCallError = new Error("No Server Connection");
    objectAssign(telefunctionCallError, { isConnectionError: true });
    throw telefunctionCallError;
  }
  const statusCode = response.status;
  if (statusCode === STATUS_CODE_SUCCESS) {
    const { ret } = await parseResponseBody(response, callContext);
    const telefunctionReturn = ret;
    return { telefunctionReturn };
  } else if (statusCode === STATUS_CODE_ABORT) {
    const { ret } = await parseResponseBody(response, callContext);
    const abortValue = ret;
    const telefunctionCallError = new Error(`Aborted telefunction call ${callContext.telefunctionName}() (${callContext.telefuncFilePath}).`);
    objectAssign(telefunctionCallError, { isAbort: true, abortValue });
    callOnAbortListeners(telefunctionCallError);
    throw telefunctionCallError;
  } else if (statusCode === STATUS_CODE_BUG) {
    const responseBody = await response.text();
    const errMsg = "Internal Server Error";
    assertUsage(responseBody === errMsg, installErr({
      reason: "an HTTP response body that Telefunc never generates",
      method,
      callContext
    }));
    throw new Error(errMsg);
  } else if (statusCode === STATUS_CODE_INVALID) {
    const responseBody = await response.text();
    assertUsage(responseBody === "Invalid Telefunc Request", installErr({
      reason: "an HTTP response body that Telefunc never generates",
      method,
      callContext
    }));
    assertUsage(false, "Try again. You may need to reload the page. (The client and server are/was out-of-sync.)");
  } else {
    assertUsage(statusCode !== 404, installErr({
      reason: "a 404 HTTP response",
      method,
      isNotInstalled: true,
      callContext
    }));
    assertUsage(false, installErr({
      reason: `a status code \`${statusCode}\` which Telefunc never uses`,
      method,
      callContext
    }));
  }
}
async function parseResponseBody(response, callContext) {
  const responseBody = await response.text();
  const responseBodyParsed = parse(responseBody);
  assertUsage(isObject(responseBodyParsed) && "ret" in responseBodyParsed, installErr({
    reason: "an HTTP response body that Telefunc never generates",
    method,
    callContext
  }));
  assert(response.status !== STATUS_CODE_ABORT || "abort" in responseBodyParsed);
  const { ret } = responseBodyParsed;
  return { ret };
}
function installErr({ reason, callContext, method: method2, isNotInstalled }) {
  let msg = [`Telefunc doesn't seem to be `];
  if (!isNotInstalled) {
    msg.push("(properly) ");
  }
  msg.push("installed on your server");
  if (reason) {
    msg.push(...[`: the HTTP ${method2} \`${callContext.telefuncUrl}\` request returned `, reason]);
  }
  msg.push(`, see https://telefunc.com/install`);
  return msg.join("");
}

// node_modules/@brillout/json-serializer/dist/esm/utils/isReactElement.js
function isReactElement(value) {
  return typeof value === "object" && value !== null && String(value["$$typeof"]) === "Symbol(react.element)";
}

// node_modules/@brillout/json-serializer/dist/esm/utils/isCallable.js
function isCallable(thing) {
  return thing instanceof Function || typeof thing === "function";
}

// node_modules/@brillout/json-serializer/dist/esm/utils/isObject.js
function isObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (Array.isArray(value)) {
    return false;
  }
  return true;
}

// node_modules/@brillout/json-serializer/dist/esm/utils/replacerWithPath.js
function replacerWithPath(replacer) {
  const pathMap = /* @__PURE__ */ new WeakMap();
  return function(key, value) {
    const pathPrevious = pathMap.get(this) ?? [];
    const path = [...pathPrevious];
    if (key !== "") {
      const pathEntry = !Array.isArray(this) ? key : parseInt(key, 10);
      path.push(pathEntry);
    }
    if (isIterable(value))
      pathMap.set(value, path);
    return replacer.call(this, key, value, path);
  };
}
function isIterable(value) {
  return value === Object(value);
}

// node_modules/@brillout/json-serializer/dist/esm/stringify.js
function stringify(value, {
  forbidReactElements,
  space,
  valueName,
  sortObjectKeys,
  // Used by Vike: https://github.com/vikejs/vike/blob/b4ba6b70e6bdc2e1f460c0d2e4c3faae5d0a733c/vike/node/plugin/plugins/importUserCode/v1-design/getConfigValuesSerialized.ts#L78
  replacer: replacerUserProvided
} = {}) {
  const serializer = (val) => JSON.stringify(val, replacerWithPath(replacer), space);
  return serializer(value);
  function replacer(key, value2, path) {
    {
      const ret = replacerUserProvided == null ? void 0 : replacerUserProvided.call(this, key, value2);
      if (ret)
        return ret.replacement;
    }
    if (forbidReactElements && isReactElement(value2)) {
      throw genErr({
        value: value2,
        valueType: "React element",
        path,
        rootValueName: valueName
      });
    }
    if (isCallable(value2)) {
      const functionName = value2.name;
      throw genErr({
        value: value2,
        valueType: "function",
        path,
        rootValueName: valueName,
        problematicValueName: path.length === 0 ? functionName : void 0
      });
    }
    const valueOriginal = this[key];
    for (const { is, serialize } of types.slice().reverse()) {
      if (is(valueOriginal)) {
        return serialize(valueOriginal, serializer);
      }
    }
    if (sortObjectKeys && isObject2(value2)) {
      const copy = {};
      Object.keys(value2).sort().forEach((key2) => {
        copy[key2] = value2[key2];
      });
      value2 = copy;
    }
    return value2;
  }
}
function genErr({ value, valueType, path, rootValueName, problematicValueName }) {
  const subjectName = getSubjectName({ path, rootValueName, problematicValueName });
  const messageCore = `cannot serialize ${subjectName} because it's a ${valueType}`;
  const err = new Error(`[@brillout/json-serializer](https://github.com/brillout/json-serializer) ${messageCore}.`);
  const pathString = getPathString(path, true);
  const errAddendum = {
    [stamp]: true,
    messageCore,
    value,
    path,
    pathString,
    subjectName
  };
  Object.assign(err, errAddendum);
  return err;
}
var stamp = "_isJsonSerializerError";
function getSubjectName({ path, rootValueName, problematicValueName }) {
  const pathString = getPathString(path, !rootValueName);
  let subjectName;
  if (!pathString) {
    subjectName = rootValueName || problematicValueName || "value";
  } else {
    if (problematicValueName) {
      subjectName = problematicValueName + " at ";
    } else {
      subjectName = "";
    }
    subjectName = subjectName + (rootValueName || "") + pathString;
  }
  return subjectName;
}
function getPathString(path, canBeFirstKey) {
  const pathString = path.map((key, i) => {
    if (typeof key === "number") {
      return `[${key}]`;
    }
    if (i === 0 && canBeFirstKey && isKeyDotNotationCompatible(key)) {
      return key;
    }
    return getPropAccessNotation(key);
  }).join("");
  return pathString;
}
function getPropAccessNotation(key) {
  return typeof key === "string" && isKeyDotNotationCompatible(key) ? `.${key}` : `[${JSON.stringify(key)}]`;
}
function isKeyDotNotationCompatible(key) {
  return /^[a-z0-9\$_]+$/i.test(key);
}

// node_modules/telefunc/dist/esm/client/remoteTelefunctionCall/serializeTelefunctionArguments.js
function serializeTelefunctionArguments(callContext) {
  const bodyParsed = {
    file: callContext.telefuncFilePath,
    name: callContext.telefunctionName,
    args: callContext.telefunctionArgs
  };
  assert(typeof callContext.telefuncFilePath === "string");
  assert(typeof callContext.telefunctionName === "string");
  assert(Array.isArray(callContext.telefunctionArgs));
  let httpRequestBody;
  try {
    httpRequestBody = stringify(bodyParsed, { forbidReactElements: true });
  } catch (err) {
    assert(hasProp(err, "message", "string"));
    assertUsage(false, [
      `Cannot serialize arguments for telefunction ${callContext.telefunctionName}() (${callContext.telefuncFilePath}).`,
      "Make sure that the arguments pass to telefunction calls are always serializable.",
      `Serialization error: ${lowercaseFirstLetter(err.message)}`
    ].join(" "));
  }
  assert(httpRequestBody);
  return httpRequestBody;
}

// node_modules/telefunc/dist/esm/client/remoteTelefunctionCall.js
async function remoteTelefunctionCall(telefuncFilePath, telefunctionName, telefunctionArgs) {
  assertUsage(isBrowser(), "The Telefunc Client is meant to be run only in the browser.");
  const callContext = {};
  {
    objectAssign(callContext, {
      telefuncFilePath,
      telefunctionName,
      telefunctionArgs
    });
  }
  objectAssign(callContext, resolveClientConfig());
  {
    const httpRequestBody = serializeTelefunctionArguments(callContext);
    objectAssign(callContext, { httpRequestBody });
  }
  const { telefunctionReturn } = await makeHttpRequest(callContext);
  return telefunctionReturn;
}
export {
  remoteTelefunctionCall as __remoteTelefunctionCall,
  configUser as config,
  onAbort,
  onTelefunctionRemoteCallError,
  configUser as telefuncConfig
};
//# sourceMappingURL=telefunc_client.js.map
