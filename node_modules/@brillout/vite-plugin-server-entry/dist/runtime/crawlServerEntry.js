"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crawlServerEntry = crawlServerEntry;
const utils_1 = require("./utils");
const import_1 = require("@brillout/import");
const serverEntryFileNameBase_1 = require("../shared/serverEntryFileNameBase");
// Use Node.js to search for the file dist/server/entry.js which we use only as fallback if:
// - the server entry isn't injected (the setting `inject` is `false`), and
// - the auto importer doesn't work.
async function crawlServerEntry(outDir) {
    let path;
    let fs;
    try {
        path = await (0, import_1.import_)('path');
        fs = await (0, import_1.import_)('fs');
    }
    catch {
        return false;
    }
    const cwd = process.cwd();
    const isPathAbsolute = (p) => {
        if (process.platform === 'win32') {
            return path.win32.isAbsolute(p);
        }
        else {
            return p.startsWith('/');
        }
    };
    if (outDir) {
        // Only pre-rendering has access to config.build.outDir
        (0, utils_1.assertPosixPath)(outDir);
        (0, utils_1.assert)(isPathAbsolute(outDir), outDir);
    }
    else {
        if (!cwd)
            return false;
        // The SSR server doesn't have access to config.build.outDir so the only option we've left is to shoot in the dark by trying with 'dist/'
        outDir = path.posix.join(cwd, 'dist');
    }
    const serverEntryFileDir = path.posix.join(outDir, 'server');
    if (!fs.existsSync(serverEntryFileDir))
        return false;
    let serverEntryFilePath = null;
    const entryFileCandidates = [
        `${serverEntryFileNameBase_1.serverEntryFileNameBase}.mjs`,
        `${serverEntryFileNameBase_1.serverEntryFileNameBase}.js`,
        `${serverEntryFileNameBase_1.serverEntryFileNameBase}.cjs`,
        `${serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative}.mjs`,
        `${serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative}.js`,
        `${serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative}.cjs`
    ];
    for (const entryFileName of entryFileCandidates) {
        const serverEntryFilePathSpeculative = path.posix.join(serverEntryFileDir, entryFileName);
        (0, utils_1.assert)(isPathAbsolute(serverEntryFilePathSpeculative));
        try {
            serverEntryFilePath = await (0, utils_1.requireResolve)(serverEntryFilePathSpeculative, 
            // Since `serverEntryFilePathSpeculative` is absolute, we can pass a wrong `currentFilePath` argument value.
            // - We avoid using `__filename` because it isn't defined when this file is included in an ESM bundle.
            // - We cannot use `import.meta.filename` (nor `import.meta.url`) because there doesn't seem to be a way to safely/conditionally access `import.meta`.
            cwd);
        }
        catch { }
    }
    (0, utils_1.assertUsage)(serverEntryFilePath, `Cannot find server entry. If you use rollupOptions.output.entryFileNames then make sure to not rename the server entry file. Make sure that one of the following exists: \n${entryFileCandidates.map((e) => `  ${e}`).join('\n')}`);
    // webpack couldn't have properly resolved distImporterPath (since there is not static import statement)
    if ((0, utils_1.isWebpackResolve)(serverEntryFilePath)) {
        return false;
    }
    await (0, import_1.import_)(serverEntryFilePath);
    return true;
}
