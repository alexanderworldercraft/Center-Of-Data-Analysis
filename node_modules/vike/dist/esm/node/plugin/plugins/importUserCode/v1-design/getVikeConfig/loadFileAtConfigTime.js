// Files loadded at config time:
export { loadImportedFile };
export { loadValueFile };
export { loadConfigFile };
import { assert, assertUsage, assertIsNotProductionRuntime, isArrayOfStrings, isObject } from '../../../../utils.js';
import { transpileAndExecuteFile } from './transpileAndExecuteFile.js';
import { assertPlusFileExport } from '../../../../../../shared/page-configs/assertPlusFileExport.js';
import pc from '@brillout/picocolors';
import { parsePointerImportData } from './transformPointerImports.js';
import { getConfigFileExport } from '../getConfigFileExport.js';
import { resolvePointerImport } from './resolvePointerImport.js';
assertIsNotProductionRuntime();
// Load pointer import
async function loadImportedFile(import_, userRootDir, importedFilesLoaded) {
    const f = import_.filePathAbsoluteFilesystem;
    if (!importedFilesLoaded[f]) {
        importedFilesLoaded[f] = transpileAndExecuteFile(import_, userRootDir, false).then((r) => r.fileExports);
    }
    const fileExports = await importedFilesLoaded[f];
    const fileExport = fileExports[import_.fileExportName];
    return fileExport;
}
// Load +{configName}.js
async function loadValueFile(interfaceValueFile, configName, userRootDir) {
    const { fileExports } = await transpileAndExecuteFile(interfaceValueFile.filePath, userRootDir, false);
    const { filePathToShowToUser } = interfaceValueFile.filePath;
    assertPlusFileExport(fileExports, filePathToShowToUser, configName);
    Object.entries(fileExports).forEach(([exportName, configValue]) => {
        const configName_ = exportName === 'default' ? configName : exportName;
        interfaceValueFile.fileExportsByConfigName[configName_] = { configValue };
    });
}
// Load +config.js, including all its extends pointer imports
async function loadConfigFile(configFilePath, userRootDir, visited, isExtensionConfig) {
    const { filePathAbsoluteFilesystem } = configFilePath;
    assertNoInfiniteLoop(visited, filePathAbsoluteFilesystem);
    const { fileExports } = await transpileAndExecuteFile(configFilePath, userRootDir, isExtensionConfig ? 'is-extension-config' : true);
    const { extendsConfigs, extendsFilePaths } = await loadExtendsConfigs(fileExports, configFilePath, userRootDir, [
        ...visited,
        filePathAbsoluteFilesystem
    ]);
    const configFile = {
        fileExports,
        filePath: configFilePath,
        extendsFilePaths
    };
    return { configFile, extendsConfigs };
}
function assertNoInfiniteLoop(visited, filePathAbsoluteFilesystem) {
    const idx = visited.indexOf(filePathAbsoluteFilesystem);
    if (idx === -1)
        return;
    const loop = visited.slice(idx);
    assert(loop[0] === filePathAbsoluteFilesystem);
    assertUsage(idx === -1, `Infinite extends loop ${[...loop, filePathAbsoluteFilesystem].join('>')}`);
}
async function loadExtendsConfigs(configFileExports, configFilePath, userRootDir, visited) {
    const { extendsPointerImportData, extendsConfigs } = getExtendsPointerImportData(configFileExports, configFilePath);
    const extendsConfigFiles = [];
    extendsPointerImportData.map((pointerImportData) => {
        const filePath = resolvePointerImport(pointerImportData, configFilePath, userRootDir);
        assert(filePath.filePathAbsoluteFilesystem);
        extendsConfigFiles.push(filePath);
    });
    await Promise.all(extendsConfigFiles.map(async (configFilePath) => {
        const result = await loadConfigFile(configFilePath, userRootDir, visited, true);
        extendsConfigs.push(result.configFile);
        extendsConfigs.push(...result.extendsConfigs);
    }));
    const extendsFilePaths = extendsConfigFiles.map((f) => f.filePathAbsoluteFilesystem);
    return { extendsConfigs, extendsFilePaths };
}
function getExtendsPointerImportData(configFileExports, configFilePath) {
    const { filePathToShowToUser } = configFilePath;
    const configFileExport = getConfigFileExport(configFileExports, filePathToShowToUser);
    const extendsConfigs = [];
    const extendsPointerImportData = [];
    if ('extends' in configFileExport) {
        const extendsValue = configFileExport.extends;
        const extendList = [];
        const wrongUsage = `${filePathToShowToUser} sets the config ${pc.cyan('extends')} to an invalid value, see https://vike.dev/extends`;
        if (typeof extendsValue === 'string') {
            extendList.push(extendsValue);
        }
        else if (isArrayOfStrings(extendsValue)) {
            extendList.push(...extendsValue);
        }
        else if (isObject(extendsValue)) {
            /* If we want to implement this then we need to make filePath optional
            extendsConfigs.push({
              fileExports: extendsValue,
              filePath: null,
            })
            */
            assertUsage(false, wrongUsage);
        }
        else {
            assertUsage(false, wrongUsage);
        }
        extendsPointerImportData.push(...extendList.map((importString) => {
            const pointerImportData = parsePointerImportData(importString);
            assertUsage(pointerImportData, wrongUsage);
            return pointerImportData;
        }));
    }
    return { extendsPointerImportData, extendsConfigs };
}
