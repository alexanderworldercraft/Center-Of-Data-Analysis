"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateShield = generateShield;
exports.logResult = logResult;
exports.testGenerateShield = testGenerateShield;
const ts_morph_1 = require("ts-morph");
const utils_1 = require("../../../utils");
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
(0, utils_1.assertModuleScope)('codegen/generateShield.ts');
const generatedShields = [];
let resutlAlreayLogged = false;
const projects = {};
function generateShield(telefuncFileCode, telefuncFilePath, appRootDir) {
    const { project, telefuncFileSource, shieldGenSource } = getProject(telefuncFilePath, telefuncFileCode, appRootDir);
    // We should preserve prior `telefuncFileCode` transformations
    telefuncFileSource.replaceWithText(telefuncFileCode);
    const telefuncFileCodeWithShield = generate({ project, telefuncFileSource, shieldGenSource, telefuncFilePath });
    return telefuncFileCodeWithShield;
}
function getProject(telefuncFilePath, telefuncFileCode, appRootDir) {
    const tsConfigFilePath = findTsConfig(telefuncFilePath, appRootDir);
    const key = tsConfigFilePath !== null && tsConfigFilePath !== void 0 ? tsConfigFilePath : '__no_tsconfig';
    const typeToShieldFilePath = node_path_1.default.join(getFilsystemRoot(), '__telefunc_typeToShield.ts');
    if (!projects[key]) {
        let project;
        if (!tsConfigFilePath) {
            project = projects[key] = new ts_morph_1.Project({
                compilerOptions: {
                    strict: true,
                },
            });
        }
        else {
            project = projects[key] = new ts_morph_1.Project({
                tsConfigFilePath,
                // Add all project files, which is needed for picking up the Telefunc.Context value
                //  - What `Telefunc.Context` is, is explained at https://telefunc.com/getContext#typescript
                skipAddingFilesFromTsConfig: false,
            });
            const compilerOptions = (0, ts_morph_1.getCompilerOptionsFromTsConfig)(tsConfigFilePath);
            (0, utils_1.assertUsage)(compilerOptions.options.strict === true, `Set \`compilerOptions.strict\` to \`true\` in ${tsConfigFilePath} (needed for shield() generation)`);
        }
        // This source file is used for evaluating the template literal types' values
        project.createSourceFile(typeToShieldFilePath, getTypeToShieldSrc());
    }
    const project = projects[key];
    (0, utils_1.objectAssign)(project, { tsConfigFilePath });
    if (!tsConfigFilePath) {
        (0, utils_1.assert)(!project.getSourceFile(telefuncFilePath));
        project.createSourceFile(telefuncFilePath, telefuncFileCode, 
        // We need `overwrite` because `telefuncFilePath` already exists on the filesystem
        { overwrite: true });
    }
    const shieldGenFilePath = node_path_1.default.join(node_path_1.default.dirname(telefuncFilePath), `__telefunc_shieldGen_${node_path_1.default.basename(telefuncFilePath)}`);
    const shieldGenSource = project.createSourceFile(shieldGenFilePath, undefined, { overwrite: true });
    shieldGenSource.addImportDeclaration({
        moduleSpecifier: getImportPath(shieldGenFilePath, typeToShieldFilePath),
        namedImports: ['ShieldArrStr'],
    });
    const telefuncFileSource = project.getSourceFile(telefuncFilePath);
    assertTelefuncFilesSource(telefuncFileSource, { project, telefuncFilePath, tsConfigFilePath, appRootDir });
    return { project, telefuncFileSource, shieldGenSource };
}
function generate({ project, telefuncFileSource, shieldGenSource, telefuncFilePath, }) {
    const telefunctions = telefuncFileSource.getFunctions().filter((f) => f.isExported());
    const telefunctionNames = telefunctions.flatMap((telefunction) => {
        const name = telefunction.getName();
        if (!name)
            return [];
        return [name];
    });
    shieldGenSource.addImportDeclaration({
        moduleSpecifier: getTelefuncFileImportPath(telefuncFilePath),
        namedImports: telefunctionNames,
    });
    // assign the template literal type to a string
    // then diagnostics are used to get the value of the template literal type
    for (const telefunctionName of telefunctionNames) {
        shieldGenSource.addTypeAlias({
            name: getShieldName(telefunctionName),
            type: `ShieldArrStr<Parameters<typeof ${telefunctionName}>>`,
        });
    }
    const shieldAlias = '__telefunc_shield'; // alias for shield
    telefuncFileSource.addImportDeclaration({
        moduleSpecifier: 'telefunc',
        namedImports: [
            {
                name: 'shield',
                alias: shieldAlias,
            },
        ],
    });
    telefuncFileSource.addVariableStatement({
        declarationKind: ts_morph_1.VariableDeclarationKind.Const,
        declarations: [
            {
                name: '__telefunc_t',
                initializer: `${shieldAlias}.type`,
            },
        ],
    });
    // Add the dependent source files to the project
    project.resolveSourceFileDependencies();
    // We need `compilerOptions.strict` to avoid `TS2589: Type instantiation is excessively deep and possibly infinite.`
    (0, utils_1.assert)(project.compilerOptions.get().strict === true);
    for (const telefunctionName of telefunctionNames) {
        const typeAliasName = getShieldName(telefunctionName);
        const typeAlias = shieldGenSource.getTypeAlias(typeAliasName);
        (0, utils_1.assert)(typeAlias, `Failed to get type alias \`${typeAliasName}\`.`);
        const shieldStrType = typeAlias.getType();
        const shieldStr = shieldStrType.getLiteralValue();
        (0, utils_1.assert)(shieldStr === undefined || typeof shieldStr === 'string');
        const failed = shieldStr === undefined;
        generatedShields.push({
            project,
            telefuncFilePath,
            telefunctionName,
            failed,
        });
        if (failed)
            continue;
        telefuncFileSource.addStatements(`${shieldAlias}(${telefunctionName}, ${shieldStr}, { __autoGenerated: true })`);
    }
    const telefuncFileCodeWithShield = telefuncFileSource.getText();
    return telefuncFileCodeWithShield;
}
function testGenerateShield(telefuncFileCode) {
    const project = new ts_morph_1.Project({
        compilerOptions: {
            strict: true,
        },
    });
    (0, utils_1.objectAssign)(project, { tsConfigFilePath: null });
    const telefuncFilePath = 'virtual.telefunc.ts';
    const telefuncFileSource = project.createSourceFile(telefuncFilePath, telefuncFileCode);
    project.createSourceFile('typeToShield.ts', getTypeToShieldSrc());
    const shieldGenSource = project.createSourceFile('shieldGen.ts');
    shieldGenSource.addImportDeclaration({
        moduleSpecifier: './typeToShield',
        namedImports: ['ShieldArrStr'],
    });
    return generate({
        project,
        telefuncFileSource,
        shieldGenSource,
        telefuncFilePath,
    });
}
function getImportPath(importer, importedFile) {
    let importPath = node_path_1.default.relative(node_path_1.default.dirname(importer), importedFile);
    importPath = toImport(importPath);
    return importPath;
}
function getTelefuncFileImportPath(telefuncFilePath) {
    let importPath = node_path_1.default.basename(telefuncFilePath);
    importPath = toImport(importPath);
    return importPath;
}
function toImport(importPath) {
    (0, utils_1.assert)(importPath.endsWith('.ts'));
    importPath = importPath.slice(0, -1 * '.ts'.length);
    if (process.platform === 'win32') {
        importPath = importPath.split('\\').join('/');
    }
    return `./${importPath}`;
}
function logResult(appRootDir, logSuccessPrefix, logIntro) {
    // `generatedShields` is empty for JavaScript users
    if (generatedShields.length === 0)
        return;
    if (resutlAlreayLogged) {
        (0, utils_1.assert)(generatedShields.length === 0);
        return;
    }
    if (logIntro)
        console.log(logIntro);
    printSuccesses(appRootDir, logSuccessPrefix);
    printFailures(appRootDir);
    resutlAlreayLogged = true;
    generatedShields.length = 0;
}
function printFailures(appRootDir) {
    const failures = generatedShields.filter((s) => s.failed);
    const projects = (0, utils_1.unique)(failures.map((f) => f.project));
    let hasTypeScriptErrors = false;
    projects.forEach((project) => {
        const diagnostics = project.getPreEmitDiagnostics();
        if (diagnostics.length > 0) {
            hasTypeScriptErrors = true;
            if (project.tsConfigFilePath) {
                console.log(`TypeScript project ${picocolors_1.default.bold(project.tsConfigFilePath)} errors:`);
            }
            else {
                console.log(`TypeScript errors:`);
            }
            console.log(project.formatDiagnosticsWithColorAndContext(diagnostics));
        }
    });
    (0, utils_1.assertWarning)(failures.length === 0, [
        'Failed to generate shield() for telefunction',
        failures.length === 1 ? '' : 's',
        ' ',
        formatGeneratedShields(failures, appRootDir),
        '.',
        !hasTypeScriptErrors
            ? ''
            : ' TypeScript errors (printed above) can be problematic for shield() generation. Fix your TypeScript errors and try again.',
        ' See https://telefunc.com/shield#typescript-automatic for more information.',
    ].join(''), { onlyOnce: true });
}
function printSuccesses(appRootDir, logSuccessPrefix) {
    const successes = generatedShields.filter((s) => !s.failed);
    if (successes.length > 0) {
        console.log([
            logSuccessPrefix,
            `shield() generated for the telefunction${generatedShields.length === 1 ? '' : 's'}`,
            formatGeneratedShields(successes, appRootDir),
        ].join(' '));
    }
}
function formatGeneratedShields(generatedShields, appRootDir) {
    return formatList(generatedShields.map(({ telefunctionName, telefuncFilePath }) => {
        telefuncFilePath = node_path_1.default.relative(appRootDir, telefuncFilePath);
        return `${telefunctionName}() (${telefuncFilePath})`;
    }));
}
function formatList(list) {
    return new Intl.ListFormat('en').format(list);
}
function getShieldName(telefunctionName) {
    return `${telefunctionName}Shield`;
}
let typeToShieldSrc;
function getTypeToShieldSrc() {
    if (!typeToShieldSrc) {
        try {
            // For build `dist/`
            typeToShieldSrc = node_fs_1.default.readFileSync(`${__dirname}/typeToShield.d.ts`).toString();
        }
        catch (_a) {
            // For Vitest
            typeToShieldSrc = node_fs_1.default.readFileSync(`${__dirname}/typeToShield.ts`).toString();
        }
    }
    (0, utils_1.assert)(typeToShieldSrc);
    (0, utils_1.assert)(typeToShieldSrc.includes('SimpleType'));
    return typeToShieldSrc;
}
function findTsConfig(telefuncFilePath, appRootDir) {
    (0, utils_1.assert)(node_fs_1.default.existsSync(telefuncFilePath));
    (0, utils_1.assertPosixPath)(telefuncFilePath);
    (0, utils_1.assertPosixPath)(appRootDir);
    (0, utils_1.assert)(telefuncFilePath.startsWith(appRootDir));
    let curr = telefuncFilePath;
    do {
        const dir = node_path_1.default.dirname(curr);
        if (dir === curr) {
            return null;
        }
        if (!dir.startsWith(appRootDir)) {
            return null;
        }
        const tsConfigFilePath = node_path_1.default.join(dir, 'tsconfig.json');
        if (node_fs_1.default.existsSync(tsConfigFilePath)) {
            return tsConfigFilePath;
        }
        curr = dir;
    } while (true);
}
function getFilsystemRoot() {
    if (process.platform !== 'win32') {
        return '/';
    }
    const fsRoot = process.cwd().split(node_path_1.default.sep)[0];
    (0, utils_1.assert)(fsRoot);
    return fsRoot;
}
function assertTelefuncFilesSource(telefuncFileSource, { telefuncFilePath, project, tsConfigFilePath, appRootDir, }) {
    if (telefuncFileSource) {
        return;
    }
    // Log an error
    const sourceFiles = project.getSourceFiles().map((sourceFile) => 
    // @ts-expect-error
    sourceFile._compilerNode.fileName);
    if (tsConfigFilePath) {
        const userTsFiles = sourceFiles.filter((filePath) => !filePath.includes('__telefunc_'));
        const msg1 = `The TypeScript configuration ${tsConfigFilePath} doesn't seem to include`;
        const msg2 = `Make sure to configure the ${picocolors_1.default.cyan('include')} and ${picocolors_1.default.cyan('exclude')} (or ${picocolors_1.default.cyan('files')}) options of that tsconfig.json`;
        if (userTsFiles.length === 0) {
            (0, utils_1.assertUsage)(false, [
                //
                `${msg1} any file (i.e. it includes 0 files).`,
                `${msg2} to match at least one file.`,
            ].join(' '));
        }
        else {
            (0, utils_1.assertUsage)(false, [
                `${msg1} the ${telefuncFilePath} file.`,
                `${msg2} to match the ${telefuncFilePath} file.`,
                `It currently matches the following files:\n${userTsFiles.map((f) => `  ${f}`).join('\n')}`,
            ].join(' '));
        }
    }
    else {
        /* Should we show TypeScript and ts-morph version?
        import { ts } from 'ts-morph'
        const typescriptVersion = ts.version
        const tsMorphVersion = require('ts-morph/package.json').version
        */
        const debugInfo = JSON.stringify({
            telefuncFilePath,
            sourceFiles,
            tsConfigFilePath,
            appRootDir,
        }, null, 2);
        (0, utils_1.assert)(false, debugInfo);
    }
}
