"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = void 0;
exports.getServerConfig = getServerConfig;
const utils_1 = require("../utils");
const configUser = new Proxy({}, { set: validateUserConfig });
exports.config = configUser;
function getServerConfig() {
    var _a, _b, _c, _d;
    return {
        disableEtag: (_a = configUser.disableEtag) !== null && _a !== void 0 ? _a : false,
        disableNamingConvention: (_b = configUser.disableNamingConvention) !== null && _b !== void 0 ? _b : false,
        shield: { dev: (_d = (_c = configUser.shield) === null || _c === void 0 ? void 0 : _c.dev) !== null && _d !== void 0 ? _d : false },
        telefuncUrl: configUser.telefuncUrl || '/_telefunc',
        telefuncFiles: (() => {
            if (configUser.telefuncFiles) {
                return configUser.telefuncFiles.map(utils_1.toPosixPath);
            }
            return null;
        })(),
        root: (() => {
            if (configUser.root) {
                return (0, utils_1.toPosixPath)(configUser.root);
            }
            if (typeof process == 'undefined' || !(0, utils_1.hasProp)(process, 'cwd'))
                return null;
            return (0, utils_1.toPosixPath)(process.cwd());
        })(),
    };
}
function validateUserConfig(configUserUnwrapped, prop, val) {
    if (prop === 'root') {
        (0, utils_1.assertUsage)(typeof val === 'string', 'config.root should be a string');
        (0, utils_1.assertUsage)((0, utils_1.pathIsAbsolute)(val), 'config.root should be an absolute path');
        configUserUnwrapped[prop] = val;
    }
    else if (prop === 'telefuncUrl') {
        (0, utils_1.assertUsage)(typeof val === 'string', 'config.telefuncUrl should be a string');
        (0, utils_1.assertUsage)(val.startsWith('/'), `config.telefuncUrl (server-side) is '${val}' but it should start with '/' (it should be a URL pathname such as '/_telefunc'), see https://telefunc.com/telefuncUrl`);
        configUserUnwrapped[prop] = val;
    }
    else if (prop === 'telefuncFiles') {
        const wrongType = 'config.telefuncFiles should be a list of paths';
        (0, utils_1.assertUsage)(Array.isArray(val), wrongType);
        val.forEach((val) => {
            (0, utils_1.assertUsage)(typeof val === 'string', wrongType);
            (0, utils_1.assertUsage)((0, utils_1.pathIsAbsolute)(val), `[config.telefuncFiles] ${val} should be an absolute path`);
            (0, utils_1.assertUsage)((0, utils_1.isTelefuncFilePath)((0, utils_1.toPosixPath)(val)), `[config.telefuncFiles] ${val} doesn't contain \`.telefunc.\``);
        });
        configUserUnwrapped[prop] = val;
    }
    else if (prop === 'disableEtag') {
        (0, utils_1.assertUsage)(typeof val === 'boolean', 'config.disableEtag should be a boolean');
        configUserUnwrapped[prop] = val;
    }
    else if (prop === 'disableNamingConvention') {
        (0, utils_1.assertUsage)(typeof val === 'boolean', 'config.disableNamingConvention should be a boolean');
        configUserUnwrapped[prop] = val;
    }
    else if (prop === 'shield') {
        (0, utils_1.assertUsage)(typeof val === 'object' && val !== null, 'config.shield should be a object');
        if ('dev' in val) {
            (0, utils_1.assertUsage)(typeof val.dev === 'boolean', 'config.shield.dev should be a boolean');
        }
        configUserUnwrapped[prop] = val;
    }
    else {
        (0, utils_1.assertUsage)(false, `Unknown config.${prop}`);
    }
    return true;
}
