export { configUser as config };
export { getServerConfig };
import { assertUsage, hasProp, toPosixPath, isTelefuncFilePath, pathIsAbsolute } from '../utils';
const configUser = new Proxy({}, { set: validateUserConfig });
function getServerConfig() {
    var _a, _b, _c, _d;
    return {
        disableEtag: (_a = configUser.disableEtag) !== null && _a !== void 0 ? _a : false,
        disableNamingConvention: (_b = configUser.disableNamingConvention) !== null && _b !== void 0 ? _b : false,
        shield: { dev: (_d = (_c = configUser.shield) === null || _c === void 0 ? void 0 : _c.dev) !== null && _d !== void 0 ? _d : false },
        telefuncUrl: configUser.telefuncUrl || '/_telefunc',
        telefuncFiles: (() => {
            if (configUser.telefuncFiles) {
                return configUser.telefuncFiles.map(toPosixPath);
            }
            return null;
        })(),
        root: (() => {
            if (configUser.root) {
                return toPosixPath(configUser.root);
            }
            if (typeof process == 'undefined' || !hasProp(process, 'cwd'))
                return null;
            return toPosixPath(process.cwd());
        })(),
    };
}
function validateUserConfig(configUserUnwrapped, prop, val) {
    if (prop === 'root') {
        assertUsage(typeof val === 'string', 'config.root should be a string');
        assertUsage(pathIsAbsolute(val), 'config.root should be an absolute path');
        configUserUnwrapped[prop] = val;
    }
    else if (prop === 'telefuncUrl') {
        assertUsage(typeof val === 'string', 'config.telefuncUrl should be a string');
        assertUsage(val.startsWith('/'), `config.telefuncUrl (server-side) is '${val}' but it should start with '/' (it should be a URL pathname such as '/_telefunc'), see https://telefunc.com/telefuncUrl`);
        configUserUnwrapped[prop] = val;
    }
    else if (prop === 'telefuncFiles') {
        const wrongType = 'config.telefuncFiles should be a list of paths';
        assertUsage(Array.isArray(val), wrongType);
        val.forEach((val) => {
            assertUsage(typeof val === 'string', wrongType);
            assertUsage(pathIsAbsolute(val), `[config.telefuncFiles] ${val} should be an absolute path`);
            assertUsage(isTelefuncFilePath(toPosixPath(val)), `[config.telefuncFiles] ${val} doesn't contain \`.telefunc.\``);
        });
        configUserUnwrapped[prop] = val;
    }
    else if (prop === 'disableEtag') {
        assertUsage(typeof val === 'boolean', 'config.disableEtag should be a boolean');
        configUserUnwrapped[prop] = val;
    }
    else if (prop === 'disableNamingConvention') {
        assertUsage(typeof val === 'boolean', 'config.disableNamingConvention should be a boolean');
        configUserUnwrapped[prop] = val;
    }
    else if (prop === 'shield') {
        assertUsage(typeof val === 'object' && val !== null, 'config.shield should be a object');
        if ('dev' in val) {
            assertUsage(typeof val.dev === 'boolean', 'config.shield.dev should be a boolean');
        }
        configUserUnwrapped[prop] = val;
    }
    else {
        assertUsage(false, `Unknown config.${prop}`);
    }
    return true;
}
